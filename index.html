<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>Endless Platformer with Moving Platforms</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
    <style type="text/css">
      body,
      html {
        background-image: url("assets/bg2.png"); /* or your background image */
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        margin: 0;
        padding: 0;
        overflow: hidden;
        width: 100%;
        height: 100%;
        font-family: "Press Start 2P", monospace;
      }

      canvas {
        display: block;
        width: 100vw !important;
        height: 100vh !important;
        touch-action: none;
      }

      /* Retro Game Over Overlay */
      .game-over-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: "Press Start 2P", monospace;
        opacity: 0;
        visibility: hidden;
        transition: all 0.5s ease-in-out;
        padding: 20px;
        box-sizing: border-box;
      }

      .game-over-overlay.show {
        background: rgba(0, 0, 0, 0.8);
        opacity: 1;
        visibility: visible;
      }

      .game-over-content {
        text-align: center;
        color: #ff0000;
        animation: retro-glow 1s ease-in-out infinite alternate;
        transform: scale(0.8);
        transition: transform 0.5s ease-out;
        max-width: 90vw;
      }

      .game-over-overlay.show .game-over-content {
        transform: scale(1);
      }

      .game-over-title {
        font-size: clamp(24px, 8vw, 48px);
        margin-bottom: 30px;
        text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 0 0 30px #ff0000;
        line-height: 1.2;
      }

      .game-over-stats {
        font-size: clamp(12px, 3vw, 16px);
        color: #ffffff;
        margin-bottom: 40px;
        line-height: 2;
      }

      .retry-button {
        background: linear-gradient(45deg, #ff0000, #cc0000);
        border: 3px solid #ffffff;
        color: #ffffff;
        font-family: "Press Start 2P", monospace;
        font-size: clamp(10px, 2.5vw, 16px);
        padding: clamp(10px, 3vw, 15px) clamp(20px, 5vw, 30px);
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        margin: 5px;
      }

      .retry-button:hover {
        background: linear-gradient(45deg, #cc0000, #990000);
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        transform: scale(1.05);
      }

      .button-container {
        display: flex;
        gap: clamp(10px, 3vw, 20px);
        justify-content: center;
        flex-wrap: wrap;
        align-items: center;
      }

      .home-button {
        background: linear-gradient(45deg, #0066cc, #004499);
        border: 3px solid #ffffff;
        color: #ffffff;
        font-family: "Press Start 2P", monospace;
        font-size: clamp(10px, 2.5vw, 16px);
        padding: clamp(10px, 3vw, 15px) clamp(20px, 5vw, 30px);
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        box-shadow: 0 0 20px rgba(0, 102, 204, 0.5);
        margin: 5px;
      }

      .home-button:hover {
        background: linear-gradient(45deg, #004499, #003366);
        box-shadow: 0 0 30px rgba(0, 102, 204, 0.8);
        transform: scale(1.05);
      }

      @keyframes retro-glow {
        from {
          text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 0 0 30px #ff0000;
        }
        to {
          text-shadow: 0 0 20px #ff0000, 0 0 30px #ff0000, 0 0 40px #ff0000;
        }
      }

      /* Mobile Controls - Responsive Design */
      .mobile-controls {
        position: fixed;
        bottom: clamp(10px, 3vh, 30px);
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        width: min(90vw, 400px);
        z-index: 2000;
        gap: clamp(20px, 5vw, 40px);
      }

      .control-group {
        display: flex;
        gap: clamp(8px, 2vw, 15px);
        align-items: center;
      }

      .mobile-controls button {
        width: clamp(45px, 12vw, 70px);
        height: clamp(45px, 12vw, 70px);
        border-radius: 50%;
        font-size: clamp(16px, 4vw, 28px);
        font-weight: bold;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: 2px solid #fff;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        outline: none;
        transition: all 0.2s ease;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      .mobile-controls button:active {
        background: rgba(255, 0, 0, 0.8);
        transform: scale(0.95);
      }

      .mobile-controls button:hover {
        background: rgba(50, 50, 50, 0.8);
      }

      /* Jump button special styling */
      #btn-up {
        background: rgba(0, 150, 0, 0.7);
        width: clamp(50px, 14vw, 80px);
        height: clamp(50px, 14vw, 80px);
      }

      #btn-up:active {
        background: rgba(0, 255, 0, 0.8);
      }

      /* Desktop hide controls option */
      @media (min-width: 1024px) and (pointer: fine) {
        .mobile-controls {
          opacity: 0.3;
          transition: opacity 0.3s ease;
        }

        .mobile-controls:hover {
          opacity: 1;
        }
      }

      /* Extra small devices */
      @media (max-width: 480px) {
        .game-over-content {
          padding: 10px;
        }

        .game-over-stats {
          margin-bottom: 30px;
        }

        .button-container {
          flex-direction: column;
          gap: 15px;
        }

        .retry-button,
        .home-button {
          min-width: 200px;
        }
      }

      /* Landscape orientation adjustments */
      @media (orientation: landscape) and (max-height: 600px) {
        .game-over-title {
          font-size: clamp(20px, 6vh, 36px);
          margin-bottom: 15px;
        }

        .game-over-stats {
          font-size: clamp(10px, 2.5vh, 14px);
          margin-bottom: 20px;
        }

        .mobile-controls {
          bottom: clamp(5px, 2vh, 15px);
        }

        .mobile-controls button {
          width: clamp(40px, 8vh, 60px);
          height: clamp(40px, 8vh, 60px);
          font-size: clamp(14px, 3vh, 22px);
        }

        #btn-up {
          width: clamp(45px, 10vh, 70px);
          height: clamp(45px, 10vh, 70px);
        }
      }

      /* Tablet adjustments */
      @media (min-width: 768px) and (max-width: 1023px) {
        .mobile-controls {
          width: min(70vw, 350px);
        }

        .game-over-title {
          font-size: clamp(30px, 6vw, 42px);
        }
      }

      /* Very wide screens */
      @media (min-width: 1920px) {
        .game-over-title {
          font-size: 48px;
        }

        .game-over-stats {
          font-size: 16px;
        }

        .retry-button,
        .home-button {
          font-size: 16px;
          padding: 15px 30px;
        }
      }

      .mobile-controls button {
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+/Edge */
        user-select: none; /* Standard */
        -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        -webkit-touch-callout: none; /* Disable callout menu on iOS */
      }

      @media (max-width: 480px) {
        .mobile-controls button {
          width: clamp(60px, 18vw, 90px);
          height: clamp(60px, 18vw, 90px);
          font-size: clamp(20px, 6vw, 36px);
        }
      }
    </style>
  </head>
  <body>
    <!-- Mobile Controls -->
    <div class="mobile-controls">
      <div class="control-group">
        <button id="btn-left">◀</button>
        <button id="btn-right">▶</button>
      </div>
      <div class="control-group">
        <button id="btn-up">▲</button>
      </div>
    </div>

    <!-- Retro Game Over Overlay -->
    <div id="gameOverOverlay" class="game-over-overlay">
      <div class="game-over-content">
        <div class="game-over-title">GAME OVER</div>
        <div class="game-over-stats">
          <div>FINAL SCORE: <span id="finalScore">0</span></div>
          <div>MAX HEIGHT: <span id="finalHeight">0</span></div>
        </div>
        <div class="button-container">
          <button class="retry-button" onclick="restartGame()">
            PLAY AGAIN
          </button>
          <button class="home-button" onclick="goHome()">HOME</button>
        </div>
      </div>
    </div>

    <script type="text/javascript">
      // Global variables for responsive game configuration
      let gameConfig = {
        isMobile: window.innerWidth < 768,
        isTablet: window.innerWidth >= 768 && window.innerWidth < 1024,
        isDesktop: window.innerWidth >= 1024,
      };

      // Mobile input flags
      let mobileInput = {
        left: false,
        right: false,
        up: false,
        down: false,
      };

      // Enhanced mobile controls with better touch handling
      function setupMobileControls() {
        const buttons = ["btn-left", "btn-right", "btn-up"];

        buttons.forEach((buttonId) => {
          const button = document.getElementById(buttonId);
          const inputKey = buttonId.split("-")[1];

          // Touch events
          button.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              mobileInput[inputKey] = true;
              button.style.transform = "scale(0.95)";
            },
            { passive: false }
          );

          button.addEventListener(
            "touchend",
            (e) => {
              e.preventDefault();
              mobileInput[inputKey] = false;
              button.style.transform = "scale(1)";
            },
            { passive: false }
          );

          button.addEventListener(
            "touchcancel",
            (e) => {
              e.preventDefault();
              mobileInput[inputKey] = false;
              button.style.transform = "scale(1)";
            },
            { passive: false }
          );

          // Mouse events for desktop testing
          button.addEventListener("mousedown", (e) => {
            e.preventDefault();
            mobileInput[inputKey] = true;
            button.style.transform = "scale(0.95)";
          });

          button.addEventListener("mouseup", (e) => {
            e.preventDefault();
            mobileInput[inputKey] = false;
            button.style.transform = "scale(1)";
          });

          button.addEventListener("mouseleave", (e) => {
            mobileInput[inputKey] = false;
            button.style.transform = "scale(1)";
          });
        });
      }

      setupMobileControls();

      // Prevent double-tap zoom
      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        function (event) {
          const now = new Date().getTime();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        },
        false
      );

      // Prevent scrolling on touch devices
      document.addEventListener(
        "touchmove",
        function (e) {
          e.preventDefault();
        },
        { passive: false }
      );

      var player;
      var stars;
      var bombs;
      var platforms;
      var movingPlatforms;
      var cursors;
      var score = 0;
      var gameOver = false;
      var heightText;
      var scoreText;
      var timerText;
      var timeLeft = 60;
      var gameStartTime;
      var highestY = 0;
      var startingY = 0;
      var lastPlatformY = 0;
      var lastPlatformX = 0;

      // Responsive game configuration
      function getResponsiveConfig() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        return {
          type: Phaser.AUTO,
          width: width,
          height: height,
          physics: {
            default: "arcade",
            arcade: {
              gravity: { y: gameConfig.isMobile ? 250 : 300 },
              debug: false,
            },
          },
          scene: {
            preload: preload,
            create: create,
            update: update,
          },
          scale: {
            mode: Phaser.Scale.RESIZE,
            autoCenter: Phaser.Scale.CENTER_BOTH,
          },
        };
      }

      var game = new Phaser.Game(getResponsiveConfig());

      function preload() {
        this.load.image("sky", "assets/bg2.png");
        this.load.image("ground", "assets/platform.png");
        this.load.image("base", "assets/platform2.png");
        this.load.image("star", "assets/star.png");
        this.load.image("bomb", "assets/bomb.png");
        this.load.spritesheet("dude", "assets/PM_Run.png", {
          frameWidth: 32,
          frameHeight: 32,
        });
        this.load.spritesheet("idle", "assets/PM_Idle.png", {
          frameWidth: 32,
          frameHeight: 32,
        });
        this.load.spritesheet("jump", "assets/PM_Jump.png", {
          frameWidth: 32,
          frameHeight: 32,
        });
        this.load.spritesheet("death", "assets/PM_Death.png", {
          frameWidth: 32,
          frameHeight: 32,
        });
      }

      function create() {
        // Update game config based on current screen size
        updateGameConfig();

        // Set world bounds for endless scrolling
        this.physics.world.setBounds(0, -10000, this.cameras.main.width, 20000);

        // Background
        this.bg = this.add.image(0, 0, "sky");
        this.bg.setOrigin(0, 0);
        this.bg.setDisplaySize(
          this.cameras.main.width,
          this.cameras.main.height
        );
        this.bg.setScrollFactor(0);

        // Platforms
        platforms = this.physics.add.staticGroup();
        movingPlatforms = this.physics.add.group();

        // Initial ground platform (responsive width)
        var startPlatform = platforms.create(
          this.cameras.main.width / 2,
          this.cameras.main.height - 50,
          "base"
        );
        startPlatform.setScale(this.cameras.main.width / 400, 1).refreshBody();

        lastPlatformY = this.cameras.main.height - 50;
        lastPlatformX = this.cameras.main.width / 2;

        // Player with responsive scaling
        const playerScale = gameConfig.isMobile ? 1.2 : 1.5;
        player = this.physics.add.sprite(
          this.cameras.main.width / 2,
          this.cameras.main.height - 100,
          "dude"
        );

        player.setScale(playerScale);
        player.setBounce(0.2);
        player.setCollideWorldBounds(true);

        // Initialize starting position and highestY correctly
        startingY = player.y;
        highestY = player.y;

        // Camera follow with responsive deadzone
        this.cameras.main.startFollow(player);
        const deadzoneWidth =
          this.cameras.main.width * (gameConfig.isMobile ? 0.4 : 0.3);
        const deadzoneHeight =
          this.cameras.main.height * (gameConfig.isMobile ? 0.4 : 0.3);
        this.cameras.main.setDeadzone(deadzoneWidth, deadzoneHeight);

        // Animations
        this.anims.create({
          key: "left",
          frames: this.anims.generateFrameNumbers("dude", { start: 0, end: 5 }),
          frameRate: 10,
          repeat: -1,
        });

        this.anims.create({
          key: "turn",
          frames: [{ key: "dude", frame: 0 }],
          frameRate: 20,
        });

        this.anims.create({
          key: "idle",
          frames: this.anims.generateFrameNumbers("idle", { start: 0, end: 3 }),
          frameRate: 10,
          repeat: -1,
        });

        this.anims.create({
          key: "right",
          frames: this.anims.generateFrameNumbers("dude", { start: 0, end: 5 }),
          frameRate: 10,
          repeat: -1,
        });

        this.anims.create({
          key: "jump",
          frames: this.anims.generateFrameNumbers("jump", { start: 0, end: 7 }),
          frameRate: 15,
          repeat: 0,
        });

        this.anims.create({
          key: "death",
          frames: this.anims.generateFrameNumbers("death", {
            start: 0,
            end: 7,
          }),
          frameRate: 15,
          repeat: 0,
        });

        // Input
        cursors = this.input.keyboard.createCursorKeys();

        // Stars & bombs
        stars = this.physics.add.group();
        bombs = this.physics.add.group();

        // Responsive UI text
        const fontSize = gameConfig.isMobile ? "20px" : "28px";

        scoreText = this.add.text(16, 16, "Score: 0", {
          fontSize: fontSize,
          fill: "#000",
        });
        scoreText.setScrollFactor(0);

        heightText = this.add.text(
          16,
          gameConfig.isMobile ? 40 : 50,
          "Height: 0",
          {
            fontSize: fontSize,
            fill: "#000",
          }
        );
        heightText.setScrollFactor(0);

        timerText = this.add.text(
          this.cameras.main.width - 16,
          16,
          "Time: 60",
          {
            fontSize: fontSize,
            fill: "#000",
          }
        );
        timerText.setOrigin(1, 0);
        timerText.setScrollFactor(0);

        // Initialize game start time
        gameStartTime = this.time.now;

        // Colliders
        this.physics.add.collider(player, platforms);
        this.physics.add.collider(player, movingPlatforms);
        this.physics.add.collider(stars, platforms);
        this.physics.add.collider(stars, movingPlatforms);
        this.physics.add.collider(bombs, platforms);
        this.physics.add.collider(bombs, movingPlatforms);

        this.physics.add.overlap(player, stars, collectStar, null, this);
        this.physics.add.collider(player, bombs, hitBomb, null, this);

        // Generate initial platforms with responsive count
        const initialPlatforms = gameConfig.isMobile ? 15 : 20;
        const initialStars = gameConfig.isMobile ? 8 : 12;
        generatePlatformBatch.call(this, initialPlatforms, initialStars);

        // Handle resize events
        this.handleResize = function () {
          updateGameConfig();

          if (scoreText && heightText && timerText) {
            const fontSize = gameConfig.isMobile ? "20px" : "28px";
            scoreText.setStyle({ fontSize: fontSize });
            heightText.setStyle({ fontSize: fontSize });
            timerText.setStyle({ fontSize: fontSize });

            timerText.setPosition(this.cameras.main.width - 16, 16);
            heightText.setPosition(16, gameConfig.isMobile ? 40 : 50);
          }

          if (this.bg) {
            this.bg.setDisplaySize(
              this.cameras.main.width,
              this.cameras.main.height
            );
          }

          if (this.cameras.main) {
            const deadzoneWidth =
              this.cameras.main.width * (gameConfig.isMobile ? 0.4 : 0.3);
            const deadzoneHeight =
              this.cameras.main.height * (gameConfig.isMobile ? 0.4 : 0.3);
            this.cameras.main.setDeadzone(deadzoneWidth, deadzoneHeight);
          }

          this.physics.world.setBounds(
            0,
            -10000,
            this.cameras.main.width,
            20000
          );
        };

        this.scale.on("resize", this.handleResize, this);
      }

      function updateGameConfig() {
        gameConfig.isMobile = window.innerWidth < 768;
        gameConfig.isTablet =
          window.innerWidth >= 768 && window.innerWidth < 1024;
        gameConfig.isDesktop = window.innerWidth >= 1024;
      }

      function update() {
        if (gameOver) return;

        // Update timer
        const elapsedTime = (this.time.now - gameStartTime) / 1000;
        timeLeft = Math.max(0, 60 - elapsedTime);
        timerText.setText("Time: " + Math.ceil(timeLeft));

        // Check if time is up
        if (timeLeft <= 0 && !gameOver) {
          this.physics.pause();
          player.setTint(0xff0000);
          player.anims.play("death");
          gameOver = true;

          setTimeout(() => {
            showGameOverScreen();
          }, 1000);
          return;
        }

        // Check if player has fallen too far below the lowest platform
        const fallThreshold = gameConfig.isMobile ? 600 : 800;
        let lowestPlatformY = startingY;

        platforms.children.entries.forEach((platform) => {
          if (platform.active && platform.y > lowestPlatformY) {
            lowestPlatformY = platform.y;
          }
        });

        movingPlatforms.children.entries.forEach((platform) => {
          if (platform.active && platform.y > lowestPlatformY) {
            lowestPlatformY = platform.y;
          }
        });

        if (player.y > lowestPlatformY + fallThreshold && !gameOver) {
          this.physics.pause();
          player.setTint(0xff0000);
          player.anims.play("death");
          gameOver = true;

          setTimeout(() => {
            showGameOverScreen();
          }, 1000);
          return;
        }

        // Responsive movement controls
        const moveSpeed = gameConfig.isMobile ? 250 : 300;
        const jumpSpeed = gameConfig.isMobile ? 320 : 350;

        // Movement
        if (cursors.left.isDown || mobileInput.left) {
          player.setVelocityX(-moveSpeed);
          player.setFlipX(true);
          player.anims.play("right", true);
        } else if (cursors.right.isDown || mobileInput.right) {
          player.setVelocityX(moveSpeed);
          player.setFlipX(false);
          player.anims.play("right", true);
        } else {
          player.setVelocityX(0);
          if (player.body.touching.down) {
            player.anims.play("idle", true);
          } else {
            player.anims.play("jump", true);
          }
        }

        if (
          (cursors.up.isDown || mobileInput.up) &&
          player.body.touching.down
        ) {
          player.setVelocityY(-jumpSpeed);
        }

        // Track highest height
        if (player.y < highestY) {
          highestY = player.y;
          const currentHeight = Math.floor((startingY - highestY) / 10);
          heightText.setText("Height: " + currentHeight);
        }

        // Generate new platforms ahead
        if (player.y < lastPlatformY + 500) {
          const batchSize = gameConfig.isMobile ? 3 : 5;
          const starCount = gameConfig.isMobile ? 2 : 3;
          generatePlatformBatch.call(this, batchSize, starCount);
        }

        // Bomb patrol logic
        bombs.children.entries.forEach((bomb) => {
          if (bomb.active && bomb.platformX) {
            var platformLeft = bomb.platformX - bomb.platformWidth / 2;
            var platformRight = bomb.platformX + bomb.platformWidth / 2;

            if (bomb.x <= platformLeft && bomb.body.velocity.x < 0) {
              bomb.setVelocityX(Math.abs(bomb.body.velocity.x));
            } else if (bomb.x >= platformRight && bomb.body.velocity.x > 0) {
              bomb.setVelocityX(-Math.abs(bomb.body.velocity.x));
            }
          }
        });

        // Moving platform logic
        movingPlatforms.children.iterate(function (platform) {
          if (platform && platform.active && platform.isMoving) {
            platform.x +=
              platform.moveSpeed * platform.moveDirection * (1 / 60);
            if (platform.x < platform.minX) {
              platform.x = platform.minX;
              platform.moveDirection = 1;
            } else if (platform.x > platform.maxX) {
              platform.x = platform.maxX;
              platform.moveDirection = -1;
            }
          }
        });

        // Keep stars aligned with moving platforms
        stars.children.entries.forEach((star) => {
          if (star.active && star.platform) {
            star.x = star.platform.x + star.platformOriginalX;
          }
        });

        // Keep bombs aligned with moving platforms
        bombs.children.entries.forEach((bomb) => {
          if (bomb.active && bomb.platform) {
            bomb.x = bomb.platform.x + bomb.platformOriginalX;
          }
        });

        // Destroy platforms below screen
        const destroyDistance = 1000;
        platforms.children.entries.forEach((platform) => {
          if (platform.active && platform.y > player.y + destroyDistance) {
            if (platform.hasStar && platform.hasStar.active) {
              platform.hasStar.destroy();
              platform.hasStar = null;
            }
            if (platform.hasBomb && platform.hasBomb.active) {
              platform.hasBomb.destroy();
              platform.hasBomb = null;
            }
            platform.destroy();
          }
        });

        movingPlatforms.children.entries.forEach(function (platform) {
          if (platform.active && platform.y > player.y + destroyDistance) {
            if (platform.hasStar && platform.hasStar.active) {
              platform.hasStar.destroy();
              platform.hasStar = null;
            }
            if (platform.hasBomb && platform.hasBomb.active) {
              platform.hasBomb.destroy();
              platform.hasBomb = null;
            }
            platform.destroy();
          }
        });

        // Carry player with moving platform
        if (player.body.touching.down) {
          movingPlatforms.children.entries.forEach(function (platform) {
            if (
              platform.active &&
              Phaser.Geom.Intersects.RectangleToRectangle(
                player.getBounds(),
                platform.getBounds()
              )
            ) {
              player.x +=
                platform.moveSpeed * platform.moveDirection * (1 / 60);
            }
          });
        }
      }

      // Responsive platform generation
      function generatePlatformBatch(count, starsCount) {
        const starIndices = [];

        while (starIndices.length < starsCount) {
          const randomIndex = Phaser.Math.Between(0, count - 1);
          if (!starIndices.includes(randomIndex)) {
            starIndices.push(randomIndex);
          }
        }

        for (let i = 0; i < count; i++) {
          const shouldHaveStar = starIndices.includes(i);
          generatePlatform.call(this, shouldHaveStar);
        }
      }

      function generatePlatform(forceStar = null) {
        // Responsive platform generation parameters
        const minVerticalGap = gameConfig.isMobile ? 120 : 140;
        const maxVerticalGap = gameConfig.isMobile ? 180 : 200;
        const platformY =
          lastPlatformY - Phaser.Math.Between(minVerticalGap, maxVerticalGap);

        const maxJumpDistance = gameConfig.isMobile ? 180 : 200;
        const minHorizontalGap = gameConfig.isMobile ? 80 : 100;

        const leftRangeMin = Math.max(100, lastPlatformX - maxJumpDistance);
        const leftRangeMax = Math.max(100, lastPlatformX - minHorizontalGap);

        const rightRangeMin = Math.min(
          this.cameras.main.width - 100,
          lastPlatformX + minHorizontalGap
        );
        const rightRangeMax = Math.min(
          this.cameras.main.width - 100,
          lastPlatformX + maxJumpDistance
        );

        let platformX;

        const leftRangeValid = leftRangeMin < leftRangeMax;
        const rightRangeValid = rightRangeMin < rightRangeMax;

        if (leftRangeValid && rightRangeValid) {
          if (Phaser.Math.Between(0, 1) === 0) {
            platformX = Phaser.Math.Between(leftRangeMin, leftRangeMax);
          } else {
            platformX = Phaser.Math.Between(rightRangeMin, rightRangeMax);
          }
        } else if (leftRangeValid) {
          platformX = Phaser.Math.Between(leftRangeMin, leftRangeMax);
        } else if (rightRangeValid) {
          platformX = Phaser.Math.Between(rightRangeMin, rightRangeMax);
        } else {
          const minX = Math.max(100, lastPlatformX - maxJumpDistance);
          const maxX = Math.min(
            this.cameras.main.width - 100,
            lastPlatformX + maxJumpDistance
          );
          platformX = Phaser.Math.Between(minX, maxX);
        }

        // Responsive platform width
        const minWidth = gameConfig.isMobile ? 180 : 220;
        const maxWidth = gameConfig.isMobile ? 250 : 300;
        const platformWidth = Phaser.Math.Between(minWidth, maxWidth);

        // Moving platform logic with responsive probability
        const movingChance = gameConfig.isMobile ? 25 : 40; // Less moving platforms on mobile for easier gameplay
        const isMoving = Phaser.Math.Between(0, 100) < movingChance;
        let platform;

        if (isMoving) {
          platform = movingPlatforms.create(platformX, platformY, "ground");
          platform.body.allowGravity = false;
          platform.setImmovable(true);
          platform.isMoving = true;
          platform.moveDirection = Phaser.Math.Between(0, 1) === 0 ? 1 : -1;
          platform.moveSpeed = gameConfig.isMobile
            ? Phaser.Math.Between(40, 80)
            : Phaser.Math.Between(50, 120);

          // Responsive movement range
          const moveRange = gameConfig.isMobile ? 50 : 60;
          platform.minX = Math.max(100, platformX - moveRange);
          platform.maxX = Math.min(
            this.cameras.main.width - 100,
            platformX + moveRange
          );
        } else {
          platform = platforms.create(platformX, platformY, "ground");
          platform.isMoving = false;
        }

        platform.displayWidth = platformWidth;

        if (!platform.isMoving && platform.refreshBody) {
          platform.refreshBody();
        }

        // Only spawn stars & bombs on static platforms
        let star = null;
        let bomb = null;

        if (!isMoving) {
          // Add stars
          const hasStar =
            forceStar !== null ? forceStar : Phaser.Math.Between(0, 100) < 100;
          if (hasStar) {
            const starX = Phaser.Math.Between(
              platformX - platformWidth / 2 + 20,
              platformX + platformWidth / 2 - 20
            );
            const starY = platformY - 25;
            star = stars.create(starX, starY, "star");

            // Disable gravity on star so it doesn't fall
            star.setGravityY(0);
            star.setImmovable(true);
            star.body.allowGravity = false;

            // Responsive star scaling
            if (gameConfig.isMobile) {
              star.setScale(1.2);
            }

            platform.hasStar = star;
          }

          // Responsive bomb probability - fewer bombs on mobile
          const bombBaseChance = gameConfig.isMobile ? 30 : 40;
          const shouldHaveBomb =
            hasStar || Phaser.Math.Between(0, 100) < bombBaseChance;

          if (shouldHaveBomb) {
            let bombX = Phaser.Math.Between(
              platformX - platformWidth / 2 + 20,
              platformX + platformWidth / 2 - 20
            );

            // Try to avoid overlap with star if both exist
            if (hasStar && star) {
              let tries = 0;
              while (Math.abs(bombX - star.x) < 40 && tries < 10) {
                bombX = Phaser.Math.Between(
                  platformX - platformWidth / 2 + 20,
                  platformX + platformWidth / 2 - 20
                );
                tries++;
              }
            }

            const bombY = platformY - 25;
            bomb = bombs.create(bombX, bombY, "bomb");
            bomb.setCollideWorldBounds(true);
            bomb.setBounce(1);

            // Responsive bomb speed - slower on mobile
            const bombSpeed = gameConfig.isMobile ? 50 : 70;
            bomb.setVelocity(bombSpeed, 20);
            bomb.platformX = platformX;
            bomb.platformWidth = platformWidth;
            platform.hasBomb = bomb;

            // Responsive bomb scaling
            if (gameConfig.isMobile) {
              bomb.setScale(0.8);
            }
          }
        }

        // Update tracker
        lastPlatformY = platformY;
        lastPlatformX = platformX;
      }

      function collectStar(player, star) {
        star.disableBody(true, true);
        score += 100;
        scoreText.setText("Score: " + score);
      }

      function hitBomb(player, bomb) {
        this.physics.pause();
        player.setTint(0xff0000);
        player.anims.play("death");
        gameOver = true;

        setTimeout(() => {
          showGameOverScreen();
        }, 1000);
      }

      // Show responsive game over screen
      function showGameOverScreen() {
        const finalHeight = Math.abs(Math.floor(highestY / 10));
        document.getElementById("finalScore").textContent = score;
        document.getElementById("finalHeight").textContent = finalHeight;

        const overlay = document.getElementById("gameOverOverlay");
        setTimeout(() => {
          overlay.classList.add("show");
        }, 100);
      }

      // Restart the game
      function restartGame() {
        location.reload();
      }

      // Go to home page
      function goHome() {
        window.location.href = "home.html";
      }

      // Enhanced resize handler
      function handleResize() {
        updateGameConfig();

        // Update UI text sizes
        if (scoreText && heightText && timerText) {
          const fontSize = gameConfig.isMobile ? "20px" : "28px";
          scoreText.setStyle({ fontSize: fontSize });
          heightText.setStyle({ fontSize: fontSize });
          timerText.setStyle({ fontSize: fontSize });

          // Reposition timer text
          timerText.setPosition(this.cameras.main.width - 16, 16);

          // Adjust height text position
          heightText.setPosition(16, gameConfig.isMobile ? 40 : 50);
        }

        // Update background size
        if (this.bg) {
          this.bg.setDisplaySize(
            this.cameras.main.width,
            this.cameras.main.height
          );
        }

        // Update camera deadzone
        if (this.cameras.main) {
          const deadzoneWidth =
            this.cameras.main.width * (gameConfig.isMobile ? 0.4 : 0.3);
          const deadzoneHeight =
            this.cameras.main.height * (gameConfig.isMobile ? 0.4 : 0.3);
          this.cameras.main.setDeadzone(deadzoneWidth, deadzoneHeight);
        }

        // Update world bounds
        this.physics.world.setBounds(0, -10000, this.cameras.main.width, 20000);
      }

      // Handle window resize with debouncing
      let resizeTimeout;
      window.addEventListener("resize", function () {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (game && game.scale && game.scale.resize) {
            game.scale.resize(window.innerWidth, window.innerHeight);
          }
        }, 100);
      });

      // Prevent context menu on long press
      window.addEventListener("contextmenu", function (e) {
        e.preventDefault();
      });

      // Handle orientation changes
      window.addEventListener("orientationchange", function () {
        setTimeout(() => {
          if (game && game.scale && game.scale.resize) {
            updateGameConfig();
            game.scale.resize(window.innerWidth, window.innerHeight);
          }
        }, 500);
      });

      // Performance optimization for mobile
      if (gameConfig.isMobile) {
        // Disable right-click context menu
        document.addEventListener("contextmenu", (e) => e.preventDefault());

        // Prevent text selection
        document.onselectstart = function () {
          return false;
        };

        // Prevent drag
        document.ondragstart = function () {
          return false;
        };
      }
    </script>
  </body>
</html>
